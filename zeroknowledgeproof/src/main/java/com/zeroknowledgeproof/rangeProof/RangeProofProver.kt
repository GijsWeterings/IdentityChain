package com.zeroknowledgeproof.rangeProof

import java.math.BigInteger
import java.security.SecureRandom

class RangeProofProver (private val m: Int, val a: Int, val b: Int, val N: Composite){
    private val rand = SecureRandom()

    /**
     * Generate a range proof that [m] is in the range [[a],[b]]
     * Only the setup part of the rangeproof is performed, still missing is the interactive
     * verification between prover and verifier.
     * @param m Int
     * @param a Int
     * @param b Int
     * @return All generated parameters of the proof, excluding
     */
    fun rangeSetup(): rangeProofResult {
        // Check whether we can even generate such a proof
        if (m < a || m > b) {
            throw ZeroKnowledgeException("Cannot generate a false proof without factoring large " +
                    "integers \nPlease come back when you can factor large integers.")
        }

        /////////////////////////////////////////////
        //Init

        // Generate security parameters
        val k1 = BigInteger(2048, rand)
        val k2 = BigInteger(160, rand)

        // To generate a generator of order N, we need access to p and q.
        // Kindly ask the Trusted Third Party to do this for us.
        val tp = RangeProofTrustedParty

        // Create result data structure
//        val interactiveResult = interactiveProof()
//        interactiveResult.rpr = setupResult
        // Generate g, as an element of large order in Zn*
        val g = tp.genGenerator()
        //TODO this doesn't actually perform the correct operations yet.
        // Generate h, as an element of large order of the group generated by g.
        val h = tp.genGenerator()
        println("We have Generators\n>INIT COMPLETE")


        /////////////////////////////////////////////
        /// Step 0: Create initial commitment
        val r = generateRandomInterval(BigInteger.ZERO, k2)
        val c = g.modPow(toBigInt(m), N).times(h.modPow(r, N)).mod(N)
        println(">STEP 0 COMPLETE")

        /// Step 1: calculate c1 and c2
        val c1 = (c * calculateInverse(g.pow(a - 1), N)) % N
        val c2 = (g.pow(b + 1) * calculateInverse(c, N)) % N
        println(">STEP 1 COMPLETE")

        // Step 2: Generate rPrime, calculate cPrime, publish it.
        val rPrime = generateRandomInterval(BigInteger.ZERO, k2)
        val cPrime = (c1.modPow(toBigInt(b - m + 1), N) * h.modPow(rPrime, N)) % N

        val proofCommitted = proveTwoCommittedIntegersAreEqual(toBigInt(b - m + 1), -r, rPrime, N, g, h, c1, h, c2, cPrime)
        println(">STEP 2 COMPLETE")

        // Step 3: Choose w from Zk2 - {0}, and r'' from Zk2
        val w = generateRandomInterval(BigInteger.ONE, k2) // Lower bound is 1
        val rDPrime = generateRandomInterval(BigInteger.ZERO, k2)
        // Publicly give a proof that two integers are equal

        // This is a problem statement, because it takes impossibly long to perform cPrime^(w*w)
        val cDPrime = (cPrime.modPow(w * w, N) * h.modPow(rDPrime, N)) % N
//        proveCommittedNumberIsSquare() // LIAM, DO STUFF
        println(">STEP 3 COMPLETE")

        // Step 4: Generate m1, m2, m3
        val sum = w * w * toBigInt((m - a + 1) * (b - m + 1))
        val (m1, m2, m4) = calculateMValues(sum)
        val m3 = m4 * m4

        // Generate r1, r2, r3 such that their sum is equal to w^2 (( b - m + 1)r + r') + r''
        val (r1, r2, r3) = calculateRValues(w * w * (toBigInt(b - m + 1) * r + rPrime) + rDPrime)
        // Then, prove that m3 is a square.
        val c1Prime = (g.modPow(m1, N) * h.modPow(r1, N)) % N
        val c2Prime = (g.modPow(m2, N) * h.modPow(r2, N)) % N
        val c3Prime = (cDPrime * calculateInverse(c1Prime * c2Prime, N)) % N

//        proveCommittedNumberIsSquare()// LIAM, DO STUFF
        println(">STEP 4 COMPLETE")

        // Set-up is done
        // Put all results in the setupResult struct, return it.
        val setupResult = rangeProofResult()
        setupResult.g = g
        setupResult.h = h
        setupResult.c = c
        setupResult.c1 = c1
        setupResult.c2 = c2
        setupResult.cPrime = cPrime
        setupResult.cDPrime = cDPrime
        setupResult.c1Prime = c1Prime
        setupResult.c2Prime = c2Prime
        setupResult.c3Prime = c3Prime
        return setupResult
    }

    fun answerUniqueChallenge(setupRes: rangeProofResult, m: Int, a: Int, b: Int, challenge: interactiveProof): BigInteger {

        // Step 5: Generate s,t in Zk1 - {0} // By RangeProofVerifier
        val rpverifier = RangeProofVerifier(RangeProofTrustedParty.N, a, b)

        val (s, t) = rpverifier.requestChallenge(k1)
        interactiveResult.s = s
        interactiveResult.t = t

        // Step 6: NumberProofProver publishes x, y, u, v
        interactiveResult.x = s * m1 + m2 + m3
        interactiveResult.y = m1 + t * m2 + m3
        interactiveResult.u = s * r1 + r2 + r3
        interactiveResult.v = r1 + t * r2 + r3

        return rpverifier.verify(interactiveResult, proofCommitted)
    }
}