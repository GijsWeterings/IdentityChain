package com.zeroknowledgeproof.rangeProof

import junit.framework.Assert.assertEquals
import junit.framework.Assert.assertTrue
import org.spongycastle.asn1.x500.style.RFC4519Style.c
import java.math.BigInteger
import java.math.BigInteger.ONE
import java.math.BigInteger.ZERO
import java.security.MessageDigest
import java.security.SecureRandom
import java.security.Security
import kotlin.system.exitProcess

// An implementation based on An Efficient Range Proof Scheme by Kun Peng and Feng Bao

object RangeProofTrustedParty {
    /**
     * Generate a proof that a given number is in a range
     */
    val TWO = BigInteger.valueOf(2)
    val g = BigInteger("5866666666666666666666666666666666666666666666666666666666666666", 16)
    val rand = SecureRandom(); // SEKURE random
    private var p  = ZERO
    private var q = ZERO

    data class isSquare (
            val a: BigInteger = ZERO
    )

    data class rangeProofResult (
            var c: BigInteger = ZERO,
            var c1: BigInteger= ZERO,
            var c2: BigInteger= ZERO,
            var sameCommitment: isSquare = isSquare(),
            var cPrime: BigInteger = ZERO,
            var cDPrime: BigInteger= ZERO,
            var cDPrimeIsSquare: isSquare = isSquare(),
            var c1Prime : BigInteger= ZERO,
            var c2Prime: BigInteger= ZERO,
            var c3Prime: BigInteger= ZERO,
            var m3IsSquare: isSquare = isSquare(),
            var x: BigInteger= ZERO,
            var y: BigInteger= ZERO,
            var u: BigInteger= ZERO,
            var v: BigInteger= ZERO
    )


    fun genRangeProof(m: Int, a: Int, b: Int) : Boolean {
        //TODO: Refactor to RangeProofProver.kt
        // Check whether we can even generate such a proof
        if (m < a || m > b) {
            return false
        }

        // Init

        // Generate security parameters
        val k1 = BigInteger(2048, rand)
        val k2 = BigInteger(160, rand)
        p = BigInteger(1024, 256, rand) // SECRET
        q = BigInteger(1024, 256, rand) // SECRET
        println("We have a p and q")
        val N : BigInteger = p.multiply(q) // Can be used many times

        // Generate g, as an element of large order in Zn*
        val g = genGenerator()
        //TODO this doesn't actually perform the correct operations yet.
        // Generate h, as an element of large order of the group generated by g.
        val h = genGenerator()
        println("We have Generators\n>INIT COMPLETE")

        // Create result data structure
        var toPublish = rangeProofResult()

        /////////////////////////////////////////////
        /// Step 0: Create initial commitment
        val r = generateRandomInterval(ZERO, k2)
        val c = g.modPow(toBigInt(m), N).times(h.modPow(r, N)).mod(N)
        toPublish.c = c
        println(">STEP 0 COMPLETE")

        /// Step 1: calculate c1 and c2
        val c1 = c.times(calculateInverse(g.pow(a - 1), N)).mod(N)
        toPublish.c1 = c1
        val c2 = g.pow(b+1).times(calculateInverse(c, N)).mod(N)
        toPublish.c2 = c2
        println(">STEP 1 COMPLETE")

        // Step 2: Generate rPrime, calculate cPrime, publish it.
        val rPrime = generateRandomInterval(ZERO, k2)
        val cPrime = c1.modPow(toBigInt(b - m + 1), N).times(h.modPow(rPrime, N)).mod(N)
        proveTwoCommittedIntegersAreEqual()// LIAM, DO STUFF
        toPublish.cPrime = cPrime
        println(">STEP 2 COMPLETE")


        // Step 3: Choose w from Zk2 - {0}, and r'' from Zk2
        val w = generateRandomInterval(ONE, k2) // Lower bound is 1
        val rDPrime = generateRandomInterval(ZERO, k2)
        // Publicly give a proof that two integers are equal

        // This is a problem statement, because it takes impossibly long to perform cPrime^(w*w)
        val cDPrime = cPrime.modPow(w*w, N).times(h.modPow(rDPrime, N))
        proveCommittedNumberIsSquare() // LIAM, DO STUFF
        //TODO Yield all results so far to the Verifier
        println(">STEP 3 COMPLETE")

        // Step 4: Generate m1, m2, m3
        val sum = w*w * toBigInt((m - a + 1) * (b - m + 1))
        val (m1, m2, m4) = calculateMValues(sum)
        val m3 = m4.pow(2)
        assert(m1+m2+m3 == sum)

        // Generate r1, r2, r3 such that their sum is equal to w^2 (( b - m + 1)r + r') + r''
        val (r1, r2, r3) = calculateRValues(w * w * (toBigInt(b - m + 1) * r + rPrime) + rDPrime)
        // Then, prove that m3 is a square.
        val c1Prime = g.modPow(m1, N).times(h.modPow(r1, N)).mod(N)
        val c2Prime = g.modPow(m2, N).times(h.modPow(r2, N)).mod(N)
        val c3Prime = cDPrime.times(calculateInverse(c1Prime * c2Prime, N)).mod(N)

        proveCommittedNumberIsSquare()// LIAM, DO STUFF
        println(">STEP 4 COMPLETE")


        // Step 5: Generate s,t in Zk1 - {0} // By RangeProofVerifier
        val rpverifier = RangeProofVerifier(N)

        val (s, t) = rpverifier.requestChallenge(k1)

        // Step 6: NumberProofProver publishes x, y, u, v
        toPublish.x = s*m1 + m2 + m3
        toPublish.y = m1 + t*m2 + m3
        toPublish.u = s*r1 + r2 + r3
        toPublish.v = r1 + t*r2 + r3

        println("Verifier should check all results")
        // Step 7: NumberProofVerifier verifies ALL of these claims.

        // Assert the three things

        // Assert the rest

        assertEquals(c1.mod(N),c.times(calculateInverse(g.modPow(toBigInt(a-1), N), N)).mod(N))
        assertEquals(c2.mod(N),g.modPow(toBigInt(b+1), N).times(calculateInverse(c, N)).mod(N) )
        assertEquals(cDPrime.mod(N), c1Prime.times(c2Prime).times(c3Prime).mod(N))
        assertEquals(c1Prime.modPow(s, N).times(c2Prime).times(c3Prime).mod(N), g.modPow(toPublish.x, N).times(h.modPow(toPublish.u, N)).mod(N))
        assertEquals(c1Prime.times(c2Prime.modPow(t, N)).times(c3Prime).mod(N), g.modPow(toPublish.y, N).times(h.modPow(toPublish.v, N)).mod(N))
        assertTrue(toPublish.x > ZERO)
        assertTrue(toPublish.y > ZERO)


//        if (!c1.equals(c.divide(g.modPow(toBigInt(a - 1), N)).mod(N))) {
//            println("first")
//        } else if (!c2.equals(g.modPow(toBigInt(b + 1), N).divide(c).mod(N))) {
//            println("2")
//        } else if (!cDPrime.equals(c1Prime.times(c2Prime).times(c3Prime).mod(N))) {
//            println("3")
//        } else if (!pow(c1Prime, s).times(c2Prime).times(c3Prime).equals(g.mod(toPublish.x).times(pow(h, toPublish.u)).mod(N))) {
//            println("4")
//        } else if (!pow(c2Prime, t).times(c1Prime).times(c3Prime).equals(g.mod(toPublish.y).times(pow(h, toPublish.v)).mod(N))) {
//            println("5")
//        } else if (toPublish.x < ZERO) {
//            println("x zero")
//        } else if (toPublish.y < ZERO) {
//            println("y zero")
//        } else println("GREAT SUCCESS")

        return rpverifier.verify(toPublish)
    }


    private fun proveCommittedNumberIsSquare() {
        proveTwoCommittedIntegersAreEqual()
//        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
    }

    private fun calculateRValues(sum: BigInteger): Array<BigInteger> {
        val r1 = generateRandomInterval(ONE, sum)
        val r2 = generateRandomInterval(ONE, sum)
        val r3 = sum - r1 - r2;
        return arrayOf(r1, r2, r3)
    }

    private fun calculateMValues(upperBound: BigInteger): Array<BigInteger> {
        var m1: BigInteger
        val m2: BigInteger
        var m4: BigInteger

        do {
            m1 = generateRandomInterval(ONE, upperBound)
            m4 = generateRandomInterval(ONE, sqrt(upperBound))
        } while (upperBound - m4*m4 - m1 < ONE)

        m2 = upperBound - m4.pow(2) - m1

        return arrayOf(m1, m2, m4)
    }

    data class IntEqualResult(
        val stub: BigInteger
    )


    /**
     * @param N: Large composite, factorization unknown
     * @param g1: Element of large order in Zn*
     */
    private fun proveTwoCommittedIntegersAreEqual(committedNum: BigInteger, r1 :BigInteger, r2: BigInteger, N: BigInteger, g1 : BigInteger, h1: BigInteger, g2: BigInteger, h2: BigInteger) : commitmentReturn {

        // Init security parameters
        val b = BigInteger(512, rand)
        val t = 80
        val l = 40
        val s1 = 40
        val s2 = 552

        // Hash function H should output 2t-bit strings.


        // Step 1: Generate random numbers.
        val w = generateRandomInterval(ONE, TWO.pow(l+t) * b - ONE)
        val eta1 = generateRandomInterval(ONE, TWO.pow(l+t+s1) * N - ONE)
        val eta2 = generateRandomInterval(ONE, TWO.pow(l+t+s2) * N - ONE)

        // Generate two commitments
        val W1 = g1.modPow(w, N) * h1.modPow(eta1, N) % N
        val W1ShouldBe = g1.modPow(w, N).times(h1.modPow(eta1, N)).mod(N)
        assert(W1 == W1ShouldBe)

        val W2 = g2.modPow(w, N).times(h2.modPow(eta2, N)).mod(N)

        // Step 2: Use the hash function.
        Security.insertProviderAt(org.spongycastle.jce.provider.BouncyCastleProvider(), 1)
        val messageDigest = MessageDigest.getInstance("SHA-512")
        // Cast W1 and W2 to byte array's, append them, hash that, and cast it back to a BigInteger
        val c = BigInteger(messageDigest.digest(W1.toByteArray() + W2.toByteArray()))

        // Step 3: Compute verification parameters
        val D = w + c * committedNum;
        val D1 = eta1 + c*r1
        val D2 = eta2 + c*r2

        val E = g1.modPow(committedNum ,N).times(h1.modPow(r1, N)).mod(N)
        val F = g2.modPow(committedNum ,N).times(h2.modPow(r2, N)).mod(N)

        return commitmentReturn(c, D, D1, D2, E, F)
    }

    data class commitmentReturn (
            val c : BigInteger,
            val D : BigInteger,
            val D1: BigInteger,
            val D2: BigInteger,
            val E : BigInteger, // One of the commitments
            val F : BigInteger
    )

    private fun generateRandomInterval(lowerBound: BigInteger, upperBound: BigInteger): BigInteger {
        var res: BigInteger
        var attempts = 0
        do {
            if (attempts > 400) exitProcess(30) // TODO REMOVE
            res = BigInteger(upperBound.bitLength(), rand)
            attempts++
        } while (res > upperBound || res == ZERO || res < lowerBound)
        return res
    }

    private fun genGenerator(n: Int = 0): BigInteger {
        // Find a generator g, such that g^p mod N and g^q mod N are not equal to 1

        if (n % 100 == 1 && n > 1) println("Finding a generator is more expensive than expected:  " + n)
        val res = BigInteger(1024, rand) // Generate random number

        return if (res.mod(p) == ZERO || res.mod(q) == ZERO) { // Not relatively prime
            genGenerator(n + 1)
        } else if (res.modPow(p, p * q) == ZERO || res.modPow(q, p * q) == ZERO) { // Not a generator, EXPENSIVE CALCULATION
            genGenerator(n + 1)
        } else {
            res // HOORAY WE'VE WON
        }
    }

//        //This structure makes debugging easier as you can set breakpoints on all the cases :)

//
//
//        return true;
//    }
//
//    private fun generateInCyclicGroup(k : BigInteger) : BigInteger{
//        var temp = BigInteger(k.bitLength(),rand)
//        temp = temp.mod(k)
//
//        if(temp.equals(ZERO)){
//            temp = generateInCyclicGroup(k)
//        }
//
//        return temp
//    }
//
//
//
//
//
//    private fun generateToSum(sum: BigInteger): BigInteger {
//        var result: BigInteger = sum.plus(ONE);
//        while (result > sum) {
//            result = BigInteger(sum.bitLength(), SecureRandom())
//        }
//        return result
//    }
//
//    private fun findTwoPrimes(length: Int) : Array<BigInteger> {
//        var first = BigInteger.probablePrime(length,rand)
//        var second : BigInteger
//        do {
//            second =  BigInteger.probablePrime(length,rand)
//        }
//        while (second.equals(first))
//
//        return arrayOf(first,second)
//
//
//    }

//     Randomly choose m1, m2, m4 smaller than (non-negative) sum, such that m1 + m2 + m4^2 = sum
//    fun takeRandomM(sum: BigInteger): Array<BigInteger> {
//        val random = SecureRandom()
//        val maxForM4 = BigIntUtil.floorSquareRoot(sum)
//        val m4 = BigInteger.createRandomInRange(ZERO, maxForM4, random)
//        val remaining = sum.subtract(m4.multiply(m4))
//        val m1 = BigInteger.createRandomInRange(ZERO, remaining, random)
//        val m2 = remaining.subtract(m1)
//        return arrayOf(m1, m2, m4)
//    }
}

// From: https://stackoverflow.com/a/42205084
fun sqrt(n: BigInteger): BigInteger {
    var a = BigInteger.ONE
    var b = n.shiftRight(5).add(BigInteger.valueOf(8))
    while (b.compareTo(a) >= 0) {
        val mid = a.add(b).shiftRight(1)
        if (mid.multiply(mid).compareTo(n) > 0) {
            b = mid.subtract(BigInteger.ONE)
        } else {
            a = mid.add(BigInteger.ONE)
        }
    }
    return a.subtract(BigInteger.ONE)
}

fun toBigInt(i: Int) : BigInteger {
    return BigInteger.valueOf(i.toLong())
}

//from: https://stackoverflow.com/questions/4582277/biginteger-powbiginteger
fun pow(base: BigInteger, exponent: BigInteger): BigInteger {
    var base = base
    var exponent = exponent
    var result = BigInteger.ONE
    while (exponent.signum() > 0) {
        if (exponent.testBit(0)) result = result.multiply(base)
        base = base.multiply(base)
        exponent = exponent.shiftRight(1)
    }
    return result
}

fun hash(): ByteArray {
    Security.insertProviderAt(org.spongycastle.jce.provider.BouncyCastleProvider(), 1)
    val messageDigest = MessageDigest.getInstance("SHA-512")
    return messageDigest.digest(someBytes)
}