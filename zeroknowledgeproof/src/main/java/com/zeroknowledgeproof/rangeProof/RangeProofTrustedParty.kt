package com.zeroknowledgeproof.rangeProof

import java.math.BigInteger
import java.math.BigInteger.ONE
import java.math.BigInteger.ZERO
import java.security.SecureRandom


// An implementation based on An Efficient Range Proof Scheme by Kun Peng and Feng Bao



object RangeProofTrustedParty {
    /**
     * Generate a proof that a given number is in a range
     */
    val TWO = BigInteger.valueOf(2)
    val g = BigInteger("5866666666666666666666666666666666666666666666666666666666666666", 16)
    val rand = SecureRandom(); // SEKURE random
    private var p  = ZERO
    private var q = ZERO

    data class isSquare (
            val a: BigInteger = ZERO
    )

    data class rangeProofResult (
            var c: BigInteger = ZERO,
            var c1: BigInteger= ZERO,
            var c2: BigInteger= ZERO,
            var sameCommitment: isSquare = isSquare(),
            var cPrime: BigInteger = ZERO,
            var cDPrime: BigInteger= ZERO,
            var cDPrimeIsSquare: isSquare = isSquare(),
            var c1Prime : BigInteger= ZERO,
            var c2Prime: BigInteger= ZERO,
            var c3Prime: BigInteger= ZERO,
            var m3IsSquare: isSquare = isSquare(),
            var x: BigInteger= ZERO,
            var y: BigInteger= ZERO,
            var u: BigInteger= ZERO,
            var v: BigInteger= ZERO
    )


    fun genRangeProof(m: Int, a: Int, b: Int) : Boolean {
        //TODO: Refactor to RangeProofProver.kt
        // Check whether we can even generate such a proof
        if (m < a || m > b) {
            return false
        }

        // Init

        // Generate security parameters
        val k1 = BigInteger(2048, rand)
        val k2 = BigInteger(160, rand)
        p = BigInteger(1024, 256, rand) // SECRET
        q = BigInteger(1024, 256, rand) // SECRET
        val N : BigInteger = p.multiply(q) // Can be used many times

        // Generate g, as an element of large order in Zn*
        val g = genGenerator()
        //TODO this doesn't actually perform the correct operations yet.
        // Generate h, as an element of large order of the group generated by g.
        val h = genGenerator()

        // Create result data structure
        var toPublish = rangeProofResult()

        /////////////////////////////////////////////
        /// Step 0: Create initial commitment
        val r = generateRandomInterval(ZERO, k2)
        val c = g.modPow(toBigInt(m), N) * h.modPow(r, N)
        toPublish.c = c

        /// Step 1: calculate c1 and c2
        val c1 = c * findCyclicInverse(g.pow(a - 1), N)
        toPublish.c1 = c1
        val c2 = g.pow(b+1) * findCyclicInverse(c, N)
        toPublish.c2 = c2

        // Step 2: Generate rPrime, calculate cPrime, publish it.
        val rPrime = generateRandomInterval(ZERO, k2)
        val cPrime = c1.modPow(toBigInt(b - m + 1), N) * h.modPow(rPrime, N)
        proveTwoCommittedIntegersAreEqual()// LIAM, DO STUFF
        toPublish.cPrime = cPrime

        // Step 3: Choose w from Zk2 - {0}, and r'' from Zk2
        val w = generateRandomInterval(ONE, k2) // Lower bound is 1
        val rDPrime = generateRandomInterval(ZERO, k2)
        // Publicly give a proof that two integers are equal

        val cDPrime = pow(cPrime, w * w).mod(N).times(h.modPow(rDPrime, N))
        proveCommittedNumberIsSquare() // LIAM, DO STUFF


        // Step 4: Generate m1, m2, m3
        val sum = w*w * toBigInt((m - a + 1) * (b - m + 1))
        val (m1, m2, m4) = calculateMValues(sum)
        val m3 = m4.pow(2)
        assert(m1+m2+m3 == sum)

        // Generate r1, r2, r3 such that their sum is equal to w^2 (( b - m + 1)r + r') + r''
        val (r1, r2, r3) = calculateRValues(w * w * (toBigInt(b - m + 1) * r + rPrime) + rDPrime)
        // Then, prove that m3 is a square.
        val c1Prime = g.modPow(m1, N).times(h.modPow(r1, N)).mod(N)
        val c2Prime = g.modPow(m2, N).times(h.modPow(r2, N)).mod(N)
        val c3Prime = cDPrime.times(findCyclicInverse(c1Prime * c2Prime, N)).mod(N)

        proveCommittedNumberIsSquare()// LIAM, DO STUFF

        // Step 5: Generate s,t in Zk1 - {0} // By RangeProofVerifier
        val rpverifier = RangeProofVerifier(N)

        val s = rpverifier.generateRandomInterval(ONE, k1)
        val t = rpverifier.generateRandomInterval(ONE, k1)

        // Step 6: NumberProofProver publishes x, y, u, v

        toPublish.x = s*m1 + m2 + m3
        toPublish.y = m1 + t*m2 + m3
        toPublish.u = s*r1 + r2 + r3
        toPublish.v = r1 + t*r2 + r3


        // Step 7: NumberProofVerifier verifies ALL of these claims.
        rpverifier.verify(toPublish)

        return true
    }

    private fun proveCommittedNumberIsSquare() {
        proveTwoCommittedIntegersAreEqual()
        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
    }

    private fun calculateRValues(sum: BigInteger): Array<BigInteger> {
        val r1 = generateRandomInterval(ONE, sum)
        val r2 = generateRandomInterval(ONE, sum)
        val r3 = sum - r1 - r2;
        return arrayOf(r1, r2, r3)
    }

    private fun calculateMValues(upperBound: BigInteger): Array<BigInteger> {
        var m1: BigInteger
        val m2: BigInteger
        var m4: BigInteger

        do {
            m1 = generateRandomInterval(ONE, upperBound)
            m4 = generateRandomInterval(ONE, upperBound)
        } while (upperBound - m4*m4 - m1 < ONE)

        m2 = upperBound - m4.pow(2) - m1

        return arrayOf(m1, m2, m4)
    }

    private fun proveTwoCommittedIntegersAreEqual() {
        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
    }

    private fun generateRandomInterval(lowerBound: BigInteger, upperBound: BigInteger): BigInteger {
        var res: BigInteger
        do {
            res = BigInteger(upperBound.bitLength(), rand)
        } while (res > upperBound || res == ZERO)
        return res
    }

    private fun genGenerator(n: Int = 0): BigInteger {
        // Find a generator g, such that g^p mod N and g^q mod N are not equal to 1

        if (n % 100 == 1 && n > 1) println("Finding a generator is more expensive than expected:  " + n)
        val res = BigInteger(1024, rand) // Generate random number

        return if (res.mod(p) == ZERO || res.mod(q) == ZERO) { // Not relatively prime
            genGenerator(n + 1)
        } else if (res.modPow(p, p * q) == ZERO || res.modPow(q, p * q) == ZERO) { // Not a generator, EXPENSIVE CALCULATION
            genGenerator(n + 1)
        } else {
            g // HOORAY WE'VE WON
        }
    }

    private fun findCyclicInverse(num: BigInteger, N: BigInteger): BigInteger {
        return num;
        //TODO Implement Bezout's algorithm for cyclic inverse finding
    }


//
//    fun NumberProofProver (m: Int, a: Int, b: Int) : Boolean {
//        // Prove that boundedNumber is between lower and upper bound
//        if ((m - a + 1)*(b - m + 1) <= 0) {
//            throw IllegalArgumentException("Cannot generate proof, because this is just NOT TRUE")
//        }
//
//
//        val w = rand.nextInt(10000)
//
//        val theProof = toBigInt(w * w).times(toBigInt(m - a + 1)).times(toBigInt(b - m + 1))
//
//        val m4 = generateToSum(toBigInt(sqrt(theProof.toDouble()).toInt()))
//        val m3 = m4.times(m4);
//        val m2 = generateToSum(theProof.subtract(m3)) //Take a random int of interval [0, theProof-m3]
//        val m1 = theProof.subtract(m3).subtract(m2)      // Now m1 + m2 + m3 = w^2 * (m-a+1) * (b-m+1)
//
////        var P: BigInteger
////        var Q: BigInteger
//        var p: BigInteger
//        var q: BigInteger
////        var PminOne: BigInteger
////        var attempts = 0;
////        do {
////            P = BigInteger.probablePrime(2048, rand)
////            attempts++
////            if (attempts % 25 == 0) {
////                println("Calculating P and p, now at " + attempts + " attempts.")
////            }
////            PminOne = P.subtract(ONE).divide(BigInteger.valueOf(2))
////        } while (!PminOne.isProbablePrime(50) )
//
//        //var QPprimes = generateSafePrimes(2048, 1)
//
////        val P = QPprimes[0]
////        val Q = QPprimes[1]
//        val P = BigInteger("10884337314880555232019005600512485388635114928977749495197997511132444534784363420761844523524326951763781845571098166762818719135614858892829212280070629102254332916999805264285510188888598855891880720226108402203826465403996415246453666229849488467565977389939240636987630647810957722217092924924850583022260813143738261026077485734809492004779747492417357325821756269791278292986962899180971445135037905301057430172470769084970601366873772836422018159683586710345788686941021649183610200986497812455648197730536572177421713854416957767791850376100921811690177035025819326299687245445814727551484584402277783476019", 10)
//        val Q = BigInteger("10437558790360158623790510859672926100811669989566014388872925454878207758905617190842580772849281472689600966498109393227200905424003699620742597321371403980549610681832319041825178497454344663116250096256559313673794425491983864544939134682788052849309592394789218470604209019089144699023578101534821440986883654031516961176249508522671578368340198855445235889464318568531239257730151412951428174660257640796266671461956359403488437210402505823621394910554213838114674109439472964459901970675384069890407061015988992907036108805829209974538359143677594199385526792563393291701665742990942212051595771814287939663839", 10)
//        println(P.toString(10))
//        println(Q.toString(10))
//
//        println(1)
//
////        do {
////            Q = BigInteger.probablePrime(2048, rand)
////            attempts++
////            if (attempts % 25 == 0) {
////                println("Calculating Q and q now at " + attempts + " attempts.")
////            }
////        } while (!Q.subtract(ONE).divide(BigInteger.valueOf(2)).isProbablePrime(50) || P.equals(Q))
//
//        val N = P.multiply(Q)
//        println("We have an N")
//
//        val k1 = BigInteger(1024, rand)
//        val k2 = BigInteger(160, rand)
//
//
//        val (g,h) = findGenerators(findTwoPrimes(2048))
//        println("We have generators")
//
//        val r = BigInteger(N.bitLength(), rand)
//
//        val c = g.modPow(toBigInt(m), N).times(h.modPow(r, N)).mod(N)
//
//        println("We have a c")
//
//        val c1 = c.divide(g.modPow(toBigInt(a-1), N)).mod(N) // c1 = c/(g^a-1) modN
//        //TODO Maybe this should not be Integer division, but cyclic group division (groot crypto fun)
//        val c2 = g.modPow(toBigInt(b+1), N).divide(c).mod(N)
//        println("We have c1 and c2")
//        val rPrime = BigInteger(N.bitLength(), rand)
//
//        val cPrime = c1.modPow(toBigInt(b - m + 1), N).times(h.modPow(rPrime, N)).mod(N)
//        val rDPrime = BigInteger(N.bitLength(), rand)
//
//        val cDPrime = cPrime.modPow(toBigInt(w*w), N).times(h.modPow(rDPrime, N)).mod(N)
//
//        val publicProof = cPrime.toString(10) + "," + h.toString(10)
//        print("The Public Proof is " + publicProof)
//
//        // Prove that the hidden number is a square with base (c', h)
//        //TODO: implement, ING used a lot of classes for this
//
//        val rSum = toBigInt((w*w)*((b-m+1))).times(r) + rPrime + rDPrime
//
//        val r1 = BigInteger(160, rand)
//        val r2 = BigInteger(160, rand)
//        val r3 = rSum-r1-r2                     //r1 + r2 + r3 = rSum
//
//        val c1Prime = g.modPow(m1, N).times(h.modPow(r1,N)).mod(N)
//        val c2Prime = g.modPow(m2, N).times(h.modPow(r2,N)).mod(N)
//        val c3Prime = cDPrime.divide(c1Prime).times(c2Prime).mod(N)
//
//
//        val x = s.times(m1).plus(m2 + m3)
//        val y = m1.plus(m3).plus(t.times(m2))
//        val u = s.times(r1).plus(r2 + r3)
//        val v = r1.plus(r3).plus(t.times(r2))
//
//        //TODO: Publish x,y,u,v
//
//
//        //verify
////
////        if(!c1.equals(c.divide(g.modPow(toBigInt(a-1), N)).mod(N)) ||
////                !c2.equals(g.modPow(toBigInt(b+1), N).divide(c).mod(N)) ||
////                !cDPrime.equals(c1Prime.times(c2Prime).times(c3Prime).mod(N)) ||
////                !pow(c1Prime,s).times(c2Prime).times(c3Prime).equals(g.mod(x).times(pow(h,u)).mod(N)) ||
////                !pow(c2Prime,t).times(c1Prime).times(c3Prime).equals(g.mod(y).times(pow(h,v)).mod(N)) ||
////                x < ZERO ||
////                y < ZERO){
////            throw Exception("Verify gone wrong")
////        }
//
//        //This structure makes debugging easier as you can set breakpoints on all the cases :)
//        if(!c1.equals(c.divide(g.modPow(toBigInt(a-1), N)).mod(N))){
//            println("first")
//        } else if(!c2.equals(g.modPow(toBigInt(b+1), N).divide(c).mod(N))){
//            println("2")
//        }
//        else if(!cDPrime.equals(c1Prime.times(c2Prime).times(c3Prime).mod(N))) {
//            println("3")
//        }
//        else if(!pow(c1Prime,s).times(c2Prime).times(c3Prime).equals(g.mod(x).times(pow(h,u)).mod(N))) {
//            println("4")
//        }
//        else if(!pow(c2Prime,t).times(c1Prime).times(c3Prime).equals(g.mod(y).times(pow(h,v)).mod(N))) {
//            println("5")
//        }
//        else if(x < ZERO) {
//            println("x zero")
//        }
//        else if(y < ZERO) {
//            println("y zero")
//        }
//
//
//        return true;
//    }
//
//    fun verifier(k1 : BigInteger) {
//        s = generateInCyclicGroup(k1)
//        t = generateInCyclicGroup(k1)
//    }
//
//
//    private fun generateInCyclicGroup(k : BigInteger) : BigInteger{
//        var temp = BigInteger(k.bitLength(),rand)
//        temp = temp.mod(k)
//
//        if(temp.equals(ZERO)){
//            temp = generateInCyclicGroup(k)
//        }
//
//        return temp
//    }
//
//
//
//
//
//    private fun generateToSum(sum: BigInteger): BigInteger {
//        var result: BigInteger = sum.plus(ONE);
//        while (result > sum) {
//            result = BigInteger(sum.bitLength(), SecureRandom())
//        }
//        return result
//    }
//
//    private fun findTwoPrimes(length: Int) : Array<BigInteger> {
//        var first = BigInteger.probablePrime(length,rand)
//        var second : BigInteger
//        do {
//            second =  BigInteger.probablePrime(length,rand)
//        }
//        while (second.equals(first))
//
//        return arrayOf(first,second)
//
//
//    }

//     Randomly choose m1, m2, m4 smaller than (non-negative) sum, such that m1 + m2 + m4^2 = sum
//    fun takeRandomM(sum: BigInteger): Array<BigInteger> {
//        val random = SecureRandom()
//        val maxForM4 = BigIntUtil.floorSquareRoot(sum)
//        val m4 = BigInteger.createRandomInRange(ZERO, maxForM4, random)
//        val remaining = sum.subtract(m4.multiply(m4))
//        val m1 = BigInteger.createRandomInRange(ZERO, remaining, random)
//        val m2 = remaining.subtract(m1)
//        return arrayOf(m1, m2, m4)
//    }
}

fun toBigInt(i: Int) : BigInteger {
    return BigInteger.valueOf(i.toLong())
}

//from: https://stackoverflow.com/questions/4582277/biginteger-powbiginteger
fun pow(base: BigInteger, exponent: BigInteger): BigInteger {
    var base = base
    var exponent = exponent
    var result = BigInteger.ONE
    while (exponent.signum() > 0) {
        if (exponent.testBit(0)) result = result.multiply(base)
        base = base.multiply(base)
        exponent = exponent.shiftRight(1)
    }
    return result
}