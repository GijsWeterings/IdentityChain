package com.zeroknowledgeproof.rangeProof

import java.math.BigInteger
import java.math.BigInteger.ONE
import java.math.BigInteger.ZERO
import java.security.MessageDigest
import java.security.SecureRandom
import java.security.Security
import kotlin.system.exitProcess

// An implementation based on An Efficient Range Proof Scheme by Kun Peng and Feng Bao

object RangeProofTrustedParty {
    /**
     * Generate a proof that a given number is in a range
     */
    val TWO = BigInteger.valueOf(2)
    val rand = SecureRandom(); // SEKURE random
    private var p = ZERO
    private var q = ZERO

    fun genRangeProof(m: Int, a: Int, b: Int): Boolean {
        //TODO: Refactor to RangeProofProver.kt
        // Check whether we can even generate such a proof
        if (m < a || m > b) {
            return false
        }

        // Init

        // Generate security parameters
        val k1 = BigInteger(2048, rand)
        val k2 = BigInteger(160, rand)
        p = BigInteger(1024, 256, rand) // SECRET
        q = BigInteger(1024, 256, rand) // SECRET
        println("We have a p and q")
        val N: BigInteger = p.multiply(q) // Can be used many times

        // Create result data structure
        val setupResult = rangeProofResult()
        val interactiveResult = interactiveProof()
        interactiveResult.rpr = setupResult
        // Generate g, as an element of large order in Zn*
        val g = genGenerator()
        setupResult.g = g
        //TODO this doesn't actually perform the correct operations yet.
        // Generate h, as an element of large order of the group generated by g.
        val h = genGenerator()
        setupResult.h = h
        println("We have Generators\n>INIT COMPLETE")


        /////////////////////////////////////////////
        /// Step 0: Create initial commitment
        val r = generateRandomInterval(ZERO, k2)
        val c = g.modPow(toBigInt(m), N).times(h.modPow(r, N)).mod(N)
        setupResult.c = c
        println(">STEP 0 COMPLETE")

        /// Step 1: calculate c1 and c2
        val c1 = c.times(calculateInverse(g.pow(a - 1), N)).mod(N)
        setupResult.c1 = c1
        val c2 = g.pow(b + 1).times(calculateInverse(c, N)).mod(N)
        setupResult.c2 = c2
        println(">STEP 1 COMPLETE")

        // Step 2: Generate rPrime, calculate cPrime, publish it.
        val rPrime = generateRandomInterval(ZERO, k2)
        val cPrime = c1.modPow(toBigInt(b - m + 1), N).times(h.modPow(rPrime, N)).mod(N)
//        proveTwoCommittedIntegersAreEqual()// LIAM, DO STUFF
        setupResult.cPrime = cPrime

        val proofCommitted = proveTwoCommittedIntegersAreEqual(toBigInt(b - m + 1), -r, rPrime, N, g, h, c1, h, c2, cPrime)

        println(">STEP 2 COMPLETE")


        // Step 3: Choose w from Zk2 - {0}, and r'' from Zk2
        val w = generateRandomInterval(ONE, k2) // Lower bound is 1
        val rDPrime = generateRandomInterval(ZERO, k2)
        // Publicly give a proof that two integers are equal

        // This is a problem statement, because it takes impossibly long to perform cPrime^(w*w)
        setupResult.cDPrime = cPrime.modPow(w * w, N).times(h.modPow(rDPrime, N))
//        proveCommittedNumberIsSquare() // LIAM, DO STUFF
        //TODO Yield all results so far to the Verifier
        println(">STEP 3 COMPLETE")

        // Step 4: Generate m1, m2, m3
        val sum = w * w * toBigInt((m - a + 1) * (b - m + 1))
        val (m1, m2, m4) = calculateMValues(sum)
        val m3 = m4.pow(2)
        assert(m1 + m2 + m3 == sum)

        // Generate r1, r2, r3 such that their sum is equal to w^2 (( b - m + 1)r + r') + r''
        val (r1, r2, r3) = calculateRValues(w * w * (toBigInt(b - m + 1) * r + rPrime) + rDPrime)
        // Then, prove that m3 is a square.
        setupResult.c1Prime = g.modPow(m1, N).times(h.modPow(r1, N)).mod(N)
        setupResult.c2Prime = g.modPow(m2, N).times(h.modPow(r2, N)).mod(N)
        setupResult.c3Prime = setupResult.cDPrime.times(calculateInverse(setupResult.c1Prime * setupResult.c2Prime, N)).mod(N)

//        proveCommittedNumberIsSquare()// LIAM, DO STUFF
        println(">STEP 4 COMPLETE")


        // Step 5: Generate s,t in Zk1 - {0} // By RangeProofVerifier
        val rpverifier = RangeProofVerifier(N, a, b)

        val (s, t) = rpverifier.requestChallenge(k1)
        interactiveResult.s = s
        interactiveResult.t = t

        // Step 6: NumberProofProver publishes x, y, u, v
        interactiveResult.x = s * m1 + m2 + m3
        interactiveResult.y = m1 + t * m2 + m3
        interactiveResult.u = s * r1 + r2 + r3
        interactiveResult.v = r1 + t * r2 + r3

        return rpverifier.verify(interactiveResult, proofCommitted)
    }


    private fun proveCommittedNumberIsSquare() {
//        proveTwoCommittedIntegersAreEqual()
//        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
    }

    private fun calculateRValues(sum: BigInteger): Triple<BigInteger,BigInteger, BigInteger> {
        val r1 = generateRandomInterval(ONE, sum)
        val r2 = generateRandomInterval(ONE, sum)
        val r3 = sum - r1 - r2;
        return Triple(r1, r2, r3)
    }

    private fun calculateMValues(upperBound: BigInteger): Triple<BigInteger,BigInteger,BigInteger> {
        var m1: BigInteger
        val m2: BigInteger
        var m4: BigInteger

        do {
            m1 = generateRandomInterval(ONE, upperBound)
            m4 = generateRandomInterval(ONE, sqrt(upperBound))
        } while (upperBound - m4 * m4 - m1 < ONE)

        m2 = upperBound - m4.pow(2) - m1

        return Triple(m1, m2, m4)
    }

    /**
     * @param N: Large composite, factorization unknown
     * @param g1: Element of large order in Zn*
     */
    private fun proveTwoCommittedIntegersAreEqual(committedNum: BigInteger, r1: BigInteger, r2: BigInteger, N: BigInteger, g1: BigInteger, h1: BigInteger, g2: BigInteger, h2: BigInteger, y1: BigInteger, y2: BigInteger): commitVerification {

        // Init security parameters
        val b = BigInteger(512, rand)
        val t = 80
        val l = 40
        val s1 = 40
        val s2 = 552

        //TODO: Hash function H should output 2t-bit strings.


        // Step 1: Generate random numbers.
        val w = generateRandomInterval(ONE, TWO.pow(l + t) * b - ONE)
        val eta1 = generateRandomInterval(ONE, TWO.pow(l + t + s1) * N - ONE)
        val eta2 = generateRandomInterval(ONE, TWO.pow(l + t + s2) * N - ONE)

        // Generate two commitments
        val W1 = g1.modPow(w, N) * h1.modPow(eta1, N) % N
        val W1ShouldBe = g1.modPow(w, N).times(h1.modPow(eta1, N)).mod(N)
        assert(W1 == W1ShouldBe)

        val W2 = g2.modPow(w, N).times(h2.modPow(eta2, N)).mod(N)

        // Step 2: Use the hash function.
        Security.insertProviderAt(org.spongycastle.jce.provider.BouncyCastleProvider(), 1)
        val messageDigest = MessageDigest.getInstance("SHA-512")
        // Cast W1 and W2 to byte array's, append them, hash that, and cast it back to a BigInteger
        val c = BigInteger(messageDigest.digest(W1.toByteArray() + W2.toByteArray()))

        // Step 3: Compute verification parameters
        val D = w + c * committedNum;
        val D1 = eta1 + c * r1
        val D2 = eta2 + c * r2

        val E = g1.modPow(committedNum, N).times(h1.modPow(r1, N)).mod(N)
        val F = g2.modPow(committedNum, N).times(h2.modPow(r2, N)).mod(N)

        if (E != y1 || F != y2) {
            throw ZeroKnowledgeException("The two committments could not could be correctly constructed")
        }

        return commitVerification(g1, g2, h1, h2, E, F, c, D, D1, D2)
    }

    private fun genGenerator(n: Int = 0): BigInteger {
        // Find a generator g, such that g^p mod N and g^q mod N are not equal to 1

        if (n % 100 == 1 && n > 1) println("Finding a generator is more expensive than expected:  " + n)
        val res = BigInteger(1024, rand) // Generate random number

        return if (res.mod(p) == ZERO || res.mod(q) == ZERO) { // Not relatively prime
            genGenerator(n + 1)
        } else if (res.modPow(p, p * q) == ZERO || res.modPow(q, p * q) == ZERO) { // Not a generator, EXPENSIVE CALCULATION
            genGenerator(n + 1)
        } else {
            res // HOORAY WE'VE WON
        }
    }
}